@startuml simple_tx
Title Messaging Sequence - Simple channel transaction

box "Alice"
actor alice
entity "Alice's\nPerun Node" as alice_node
endbox

entity "Blockchain" as bc

box "Bob"
entity "Bob's\nPerun Node" as bob_node
actor bob
endbox


skinparam sequence {
    messageAlign center
    ArrowThickness 2
    BoxBorderColor Sienna
    BoxBackgroundColor SeaShell
    GroupBodyBackgroundColor transparent
    NoteTextAlignment center
    DefaultTextAlignment center
}
hide footbox

note over alice, bob
endnote

group User session setup
alice[#DarkBlue]->alice_node: New Session\n<usrMsgNewSessionRequest>
alice<-[#DarkBlue]alice_node:Session setup success / failure\n<usrMsgNewSessionResponse>
note over alice, alice_node #Pink
Terminate on session setup failure
end note
'group 
end

group Pre-setup 

group Open channel
alice[#DarkBlue]->alice_node:Open Channel with Bob\n<usrMsgNewChannelRequest>
alice_node[#Crimson]->bob_node:Channel identity request\n<chMsgIdentityRequest>
alice_node<-[#Crimson]bob_node:Channel identity response\n<chMsgIdentityResponse>

opt if identityMismatch
alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
alice<-[#DarkBlue]alice_node:New channel Identity error\n<usrMsgNewChannelResponse>
note over alice, alice_node #Pink
Terminate
endnote
'opt if identityMismatch
end

alice_node[#Crimson]->bob_node:New channel request\n<chMsgNewChannelRequest>
bob_node[#DarkBlue]->bob:New Channel request\n<usrMsgNewChannelRequest>

alt bob does not respond
alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
alice<-[#DarkBlue]alice_node:No response\n<usrMsgNewChannelResponse>
note over alice, alice_node #Pink
Terminate
endnote

else bob declines request
bob[#DarkBlue]->bob_node:Decline\n<usrMsgNewChannelResponse> 
alice_node<-[#Crimson]bob_node:New channel response declined\n<chMsgNewChannelResponse>
alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
alice<-[#DarkBlue]alice_node:New channel request declined\n<usrMsgNewChannelResponse>
note over alice, bob #Pink
Terminate
endnote

else receiver accepts request 
bob_node<-[#DarkBlue]bob:Accept\n<usrMsgNewChannelResponse>
alice_node<-[#Crimson]bob_node:New channel response accepted\n<chMsgNewChannelResponse>
alice_node[#Fuchsia]->alice_node:Set STATUS = PRESETUP
alice<-[#DarkBlue]alice_node:New channel request accepted\n<usrMsgNewChannelResponse>

'alt bob does not respond
end

'group Open channel
end


group Contracts Store Version Check
alice_node[#Crimson]->bob_node:Contract Store\n<contractStore>
alice_node<-[#Crimson]bob_node:Accepted / Declined\n<contractList>

alt if accepted (on Success)
bob_node[#Fuchsia]->bob_node:Store contract store version
alice_node[#Fuchsia]->alice_node:Store contract store version
else if declined (on Failure)
alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
alice_node[#DarkBlue]->alice:Channel setup failed\nContract store version mismatch
bob_node[#Fuchsia]->bob_node:Set STATUS = CLOSED
bob_node[#DarkBlue]->bob:Channel setup failed\nContract store version mismatch
note over alice, bob #Pink
Terminate
endnote

'alt if accepted (on Success)
end

'group Contracts Version Check
end

group Session Id (sid) Creation
alice_node[#Crimson]->bob_node:Partial Session id\n<chMsgSessionId>
alice_node<-[#Crimson]bob_node:Complete Session id\n<chMsgSessionId>
alice_node[#Crimson]->bob_node:Session id accepted\n<chMsgSessionId>
alice_node[#Fuchsia]->alice_node:Store session id
bob_node[#Fuchsia]->bob_node:Store session id
'group Session Id (sid) Creation
end

group MSContract Base state Creation
alice_node[#Crimson]->bob_node:Partially signed\nMSContract Base state\n<chMsgBaseState>
alice_node<-[#Crimson]bob_node:Fully signed\nMSContract Base state\n<chMsgBaseState>
alice_node[#Crimson]->bob_node:MSContract Base state accepted\n<chMsgBaseState>
alice_node[#Fuchsia]->alice_node:Store ms contract base state
bob_node[#Fuchsia]->bob_node:Store ms contract base state
'group MSContract Base state Creation
end

'Share signature library address
group Share signature library address (sign lib addr)
alice_node[#Crimson]->bob_node:Lib signature addr\n<chMsgContractAddr>
bob_node[#DarkOliveGreen]->bc:Verify Contract at\n<eth-addr>
bob_node<-[#DarkOliveGreen]bc:Success / Failure
alice_node<-[#Crimson]bob_node:Lib signature addr\naccepted (on Success) / declined (on Failure)\n<chMsgContractAddr>

alt if accepted (on Success)
bob_node[#Fuchsia]->bob_node:Set STATUS = SETUP
bob_node[#Fuchsia]->bob_node:Store lib signature address
alice_node[#Fuchsia]->alice_node:Set STATUS = SETUP
alice_node[#Fuchsia]->alice_node:Store lib signature address
else if declined (on Failure)
alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
alice_node[#DarkBlue]->alice:Channel setup failed\nLib signature address disagreement
bob_node[#Fuchsia]->bob_node:Set STATUS = CLOSED
bob_node[#DarkBlue]->bob:Channel setup failed\nLib signature address disagreement
note over alice_node, bob_node #Pink
Terminate
endnote

'alt if accepted (on Success)
end

'group Share signature library address (sign lib addr)
end

'group
end

group Setup

group Deploy and share MSContract
alice_node[#DarkOliveGreen]->bc:Deploy MSContract\n<Contract code>
alice_node<-[#DarkOliveGreen]bc:MSContract deployed\n<Contract addr>
alice_node[#Crimson]->bob_node:MSContract\n<chMsgContractAddr>
bob_node[#DarkOliveGreen]->bc:Verify MSContract at\n<eth-addr>
alice_node<-[#Crimson]bob_node:MSContract addr\naccepted (on Success) / declined (on Failure)\n<chMsgContractAddr>
alt if accepted (on Success)
bob_node[#Fuchsia]->bob_node:Store ms contract address
alice_node[#Fuchsia]->alice_node:Store ms contract address
else if declined (on Failure)
alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
alice_node[#DarkBlue]->alice:Channel setup failed\nMSContract address disagreement
bob_node[#Fuchsia]->bob_node:Set STATUS = CLOSED
bob_node[#DarkBlue]->bob:Channel setup failed\nMSContract address disagreement
note over alice_node, bob_node #Pink
Terminate
endnote

'alt if accepted (on Success)
end

'group Deploy and share MSContract
end

note over alice_node, bob_node #DarkSeaGreen
How nodes react is determined by their role in the channel - Sender / Receiver
Order in which they receive events and hence react may vary in runtime
Alice is Sender and Bob is Receiver
endnote

note over alice_node #DarkSeaGreen
ROLE-CH - SENDER
endnote

note over bob_node #DarkSeaGreen
ROLE-CH - RECEIVER
endnote

group OnEvent "MSContract Initialising"
alice_node<-[#DarkOliveGreen]bc:MSContract Initializing\n<event>
opt if ROLE-CH = SENDER / RECEIVER
alice_node[#Fuchsia]->alice_node:Set STATUS = INIT
alice_node[#Fuchsia]->alice_node:Set timer period = mscontract timeout
alice_node[#DarkOliveGreen]->bc:MSContract:Confirm\n<call>

'if ROLE-CH = SENDER / RECEIVER
end

bob_node<-[#DarkOliveGreen]bc:MSContract Initializing\n<event>
opt if ROLE-CH = SENDER / RECEIVER
bob_node[#Fuchsia]->bob_node:Set STATUS = INIT
bob_node[#Fuchsia]->bob_node:Set timer period = 1.5 * mscontract timeout
note over bob_node #DarkSeaGreen
1.5 is an arbitary number.
If Sender has not called refund event after 1.5 * t,
then receiver will call refund
endnote
bob_node[#DarkOliveGreen]->bc:MSContract:Confirm\n<call>

'if ROLE-CH = SENDER / RECEIVER
end

end
alt if both timers (sender and receiver) are yet to timeout
|||
group OnEvent "MSContract Initalised"
alice_node<-[#DarkOliveGreen]bc:MSContract Initialised\n<event>
opt if ROLE-CH = SENDER / RECEIVER
alice_node[#Fuchsia]->alice_node:Set STATUS = OPEN
alice_node[#Fuchsia]->alice_node:Reset and stop timer

'if ROLE-CH = SENDER / RECEIVER
end

bob_node<-[#DarkOliveGreen]bc:MSContract Initialised\n<event>
opt if ROLE-CH = SENDER / RECEIVER
bob_node[#Fuchsia]->bob_node:Set STATUS = OPEN
bob_node[#Fuchsia]->bob_node:Reset and stop timer

'if ROLE-CH = SENDER / RECEIVER
end

'group OnEvent "MSContract Initalised"
end

else if either alice / bob timer timesout

group Call "MSContract Refund"
|||
alt if alice timer times out
alice_node<-[#Fuchsia]alice_node:MSContract TimedOut\nat period = mscontract timeout

opt if STATUS = OPEN AND ROLE-CH = SENDER
alice_node[#DarkOliveGreen]->bc:MSContract:Refund\n<call>

'opt if STATUS = OPEN AND ROLE-CH = SENDER
end

else if bob timer times out
bob_node<-[#Fuchsia]bob_node:MSContract TimedOut\nat period = 1.5 * mscontract timeout

opt if STATUS = OPEN AND ROLE-CH = RECEIVER
bob_node[#DarkOliveGreen]->bc:MSContract:Refund\n<call>

'opt if STATUS = OPEN AND ROLE-CH = SENDER
end

'alt if alice timer times out
end


alice_node<-[#DarkOliveGreen]bc:MSContract Refunded\n<event>
opt if ROLE-CH = SENDER / RECEIVER
alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
alice_node[#DarkBlue]->alice:Channel setup failed\nTimedout before confirm
note over alice, alice_node #Pink
Terminate
endnote

'if ROLE-CH = SENDER / RECEIVER
end

bob_node<-[#DarkOliveGreen]bc:MSContract Refunded\n<event>
opt if ROLE-CH = SENDER / RECEIVER
bob_node[#Fuchsia]->bob_node:Set STATUS = CLOSED
bob_node[#DarkBlue]->bob:Channel setup failed\nTimedout before confirm
note over bob, bob_node #Pink
Terminate
endnote

'if ROLE-CH = SENDER / RECEIVER
end

'group OnTimeout call "MSContract Refund"
end

'alt
end

'group
end

group Setup VPC

alice_node[#DarkOliveGreen]->bc:Deploy VPC\n<Contract code>
alice_node<-[#DarkOliveGreen]bc:VPC deployed\n<Contract addr>
alice_node[#Crimson]->bob_node:VPC\n<chMsgContractAddr>
bob_node[#DarkOliveGreen]->bc:Verify VPC at\n<eth-addr>
alice_node<-[#Crimson]bob_node:VPC addr\naccepted (on Success) / declined (on Failure)\n<chMsgContractAddr>
alt if accepted (on Success)
bob_node[#Fuchsia]->bob_node:Store vpc address
alice_node[#Fuchsia]->alice_node:Store vpc address
else if declined (on Failure)
alice_node[#DarkBlue]->alice:Channel setup failed\nVPC address disagreement
bob_node[#DarkBlue]->bob:Channel setup failed\nVPC address disagreement
note over alice_node, bob_node #Pink
Terminate
endnote

'alt if accepted (on Success)
end

alice_node[#DarkOliveGreen]->bc:MSContract:State register\n<call>

group OnEvent "MSContract State Registering"
bc[#DarkOliveGreen]->alice_node:State registering\n<event>
opt if ROLE-CH = SENDER AND STATUS = OPEN
alice_node[#Fuchsia]->alice_node:Set STATUS = INCONFLICT
alice_node[#Fuchsia]->alice_node:Set timer period = mscontract timeout

'opt if ROLE-CH = SENDER
end

bc[#DarkOliveGreen]->bob_node:State registering\n<event>
opt if ROLE-CH = SENDER AND STATUS = OPEN
bob_node[#DarkOliveGreen]->bc:MSContract:State register\n<call>
bob_node[#Fuchsia]->bob_node:Set STATUS = INCONFLICT

'opt if ROLE-CH = SENDER
end

'group OnEvent "MSContract State Registering"
end


group OnEvent "MSContract State Registered"

bc[#DarkOliveGreen]->alice_node:State registered\n<event> 
opt if ROLE-CH = SENDER/RECEIVER AND STATUS = INCONFLICT
alice_node[#Fuchsia]->alice_node:Set STATUS = SETTLED
alice<-[#DarkBlue]alice_node:Channel setup successful\n<chMsgMSCBaseState>

'opt if ROLE-CH = SENDER/RECEIVER AND STATUS = INCONFLICT
end

bc[#DarkOliveGreen]->bob_node:State registered\n<event> 
opt if ROLE-CH = SENDER/RECEIVER AND STATUS = INCONFLICT
bob_node[#Fuchsia]->bob_node:Set STATUS = SETTLED
bob<-[#DarkBlue]bob_node:Channel setup successful\n<chMsgMSCBaseState>

'opt if ROLE-CH = SENDER/RECEIVER AND STATUS = INCONFLICT
end

'group OnEvent "MSContract State Registered"
end

note over alice, bob #DarkSeaGreen
Channel is setup. Parties can transact by creating new vpc states and signing them
As many transactions as required can be done. One sample for each party is shown below
endnote

'group Setup VPC
end

group Exchange state initated by alice

alice[#DarkBlue]->alice_node:Proposed new state\n<usrMsgState>
alice_node[#Crimson]->bob_node:Partially signed state\n<chMsgState>
bob_node[#DarkBlue]->bob:Confirm new state\n<usrMsgState>

alt if bob confirms new state
bob_node<-[#DarkBlue]bob:Confirmed new state\n<usrMsgState>
bob_node[#Fuchsia]->bob_node:Update state\n<state>
alice_node<-[#Crimson]bob_node:Fully signed state\n<chMsgState>
alice_node[#Fuchsia]->alice_node:Update state\n<state>
alice<-[#DarkBlue]alice_node:Confirmed new state<useMsgState>

else if bob declines new state
bob_node<-[#DarkBlue]bob:Reject new state\n<usrMsgState>
alice_node<-[#Crimson]bob_node:Rejected new state\n<chMsgState>
alice<-[#DarkBlue]alice_node:Rejected new state\n<useMsgState>

'alt
end

'group
end

group Exchange state initated by bob

bob[#DarkBlue]->bob_node:Proposed new state\n<usrMsgState>
bob_node[#Crimson]->alice_node:Partially signed state\n<chMsgState>
alice_node[#DarkBlue]->alice:Confirm new state\n<usrMsgState>

alt if alice confirms new state
alice_node<-[#DarkBlue]alice:Confirmed new state\n<usrMsgState>
alice_node[#Fuchsia]->alice_node:Update state\n<state>
bob_node<-[#Crimson]alice_node:Fully signed state\n<chMsgState>
bob_node[#Fuchsia]->bob_node:Update state\n<state>
bob<-[#DarkBlue]bob_node:Confirmed new state<useMsgState>

else if alice declines new state
alice_node<-[#DarkBlue]alice:Reject new state\n<usrMsgState>
bob_node<-[#Crimson]alice_node:Rejected new state\n<chMsgState>
bob<-[#DarkBlue]bob_node:Rejected new state\n<useMsgState>

'alt
end

'group
end

group Close channel

alice[#DarkBlue]->alice_node:Close channel\n<usrMsgFinaliseState>
alice_node[#Fuchsia]->alice_node:Set ROLE-CL = SENDER

alice_node[#DarkOliveGreen]->bc:VPC Contract:Close\n<call>


group OnEvent "VPC Closing"

alice_node<-[#DarkOliveGreen]bc:VPC Closing\n<event>
opt if ROLE-CL = SENDER AND STATUS = SETTLED
alice_node[#Fuchsia]->alice_node:Set STATUS = VPCCLOSING
alice_node[#Fuchsia]->alice_node:Set time period = vpc-extended-validity

'opt if ROLE-CL = SENDER AND STATUS = SETTLED
end

bob_node<-[#DarkOliveGreen]bc:VPC Closing\n<event>
opt if ROLE-CL != SENDER AND STATUS = SETTLED
bob_node[#Fuchsia]->bob_node:Set ROLE-CL = RECEIVER
bob_node[#Fuchsia]->bob_node:Set STATUS = VPCCLOSING
bob_node[#Fuchsia]->bob_node:Set time period = vpc validity

alt if close mode = manual
bob_node[#DarkBlue]->bob:Close call received with state\n<usrMsgFinaliseState>
bob_node<-[#DarkBlue]bob:Respond to close call\n<usrMsgFinaliseState>

opt if Response == call close

alt if now < timeout
bob_node[#Fuchsia]->bob_node:Reset and stop timer
bc<-[#DarkOliveGreen]bob_node:VPC Contract:Close\final state\n<call>
bob_node[#DarkBlue]->bob:Close called\n<usrMsgFinaliseStateClose>
else if now > timeout
bob_node[#DarkBlue]->bob:Cannot close - validity timer expired\n<usrMsgFinaliseStateClose>

'opt if Response == call close
end

'alt if now < timeout
end

else if close mode = auto-normal / auto-immediate

alt if closing state != current state
bob_node[#Fuchsia]->bob_node:Reset and stop timer
bc<-[#DarkOliveGreen]bob_node:VPC Contract:Close\correct final state\n<call>
else if closing_state == current_state AND close mode = auto-immediate
bob_node[#Fuchsia]->bob_node:Reset and stop timer
bc<-[#DarkOliveGreen]bob_node:VPC Contract:Close\nsame state\n<call>

'alt if closing state != current state
end

'alt if close mode = manual
end

'opt if ROLE-CL = RECEIVER AND STATUS = SETTLED
end

'group OnEvent "MSContract State Registering"
end

alt if SENDER times out and no event received
opt if ROLE-CL = SENDER AND STATUS = VPCCLOSING AND VPC EXTENDED VALIDITY TIMEDOUT
alice_node[#Fuchsia]->alice_node:vpc extended validity timedout
alice_node[#DarkOliveGreen]->bc:MSC Contract:Execute\n<call>

'opt if ROLE-CL = SENDER AND STATUS = VPCCLOSING
end

else if VPCClosed Event is received

group OnEvent "VPC Closed"

alice_node<-[#DarkOliveGreen]bc:VPC Closed\n<event>
opt if ROLE-CL = SENDER AND STATUS = VPCCLOSING
alice_node[#Fuchsia]->alice_node:Set STATUS = VPCCLOSED
alice_node[#Fuchsia]->alice_node:Reset and stop timer
alice_node[#DarkOliveGreen]->bc:MSC Contract:Execute\n<call>

'opt if ROLE-CL = SENDER AND STATUS = VPCCLOSING
end

bob_node<-[#DarkOliveGreen]bc:VPC Closed\n<event>
opt if ROLE-CL = RECIEVER AND STATUS = VPCCLOSING
bob_node[#Fuchsia]->bob_node:Set STATUS = VPCCLOSED

'opt if ROLE-CL = SENDER AND STATUS = SETTLED
end

'group OnEvent "VPC Closed"
end

'alt if SENDER times out and no event received
end

group OnEvent "MSContract Closed"
alice_node<-[#DarkOliveGreen]bc:MSContract Closed\n<event>
opt if ROLE-CH = SENDER AND STATUS = VPCCLOSED
alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
alice_node[#DarkBlue]->alice:Channel closed\n<usrMsgChannelClosed>
note over alice, alice_node #Pink
Terminate
endnote

'opt if ROLE-CH = SENDER AND STATUS = VPCCLOSED
end

bc[#DarkOliveGreen]->bob_node:MSContract Closed\n<event>
opt if ROLE-CH = SENDER AND STATUS = VPCCLOSED
bob_node[#Fuchsia]->bob_node:Set STATUS = CLOSED
bob_node[#DarkBlue]->bob:Channel closed\n<usrMsgChannelClosed>
note over bob, bob_node #Pink
Terminate
endnote

'opt if ROLE-CH = SENDER AND STATUS = VPCCLOSED
end

'group OnEvent "MSContract Closed"
end

'group Close channel
end

note over alice, bob #DarkSeaGreen
ROLE-CH : Role in channel.  SENDER/RECEIVER
ROLE-CL : Role in close.    SENDER/RECEIVER
endnote

@enduml
